
struct Foo<T1, T2>(x: T1, y: T2) where T1 : Something, SomethingElse foobar;


struct Foo<T1, T2> where T1 : Something, {}

 - parses Something
 - notices no comma or breakout token => error
 - parses Foobar

 - parses Something
 - errors 123 => invalid constraint
 - recovers to comma or breakout token
 - parses Foobar
 - errors 123 => invalid constraint
 - recovers to comma or breakout token

parent:
 - yo wtf is =>

fn foo<T>(t: T) -> T where T: Something {}
fn foo<T>(t: T) -> T where T: Something => t;

alias Foo<T> = vec<T> where T : Something;

interface Foo<T> where T : Something {

}

enum Foo<T> asdf where T : Something {

}