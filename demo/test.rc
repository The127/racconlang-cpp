use std::foo;

mod main;



use mod::{foo}; // missing use path // unexpected `{` // invalid module path `::`

use mod::{foo}; // `mod` is not a valid module name

mod main;

enum Foo {
    Asdf,, // unexpected `,`
    bla
}

enum Foo {
    (int,int), // missing enum member name
    bla
}

enum Foo {
    Asdf,
    (int,int), // missing enum member name
    bla
}

enum Foo {
    Asdf,
    =, // unexpected `=`
    bla
}

enum Foo {
    Asdf,
    =foo, // unexpected `=` // (foo gets parsed as a member)
    bla
}

enum Foo {
    Asdf,
    =(int,int), // unexpected `=` // missing enum member name
    bla
}

enum Foo {
    Asdf,
    foo=112, // unexpected `=`
    bla
}

enum Foo {
    Asdf,
    foo(int)=112, // unexpected `=`
    bla
}

enum Foo {
    Asdf // missing comma
    foo(int)=112, // unexpected `=`
    bla
}

enum Foo {
    Asdf; // unexpected `;` // missing comma
    foo(int)=112, // unexpected `=`
    bla
}

enum Foo {
    Asdf,
    foo(int)(123), // unexpected `(`
    bla
}


pub enum Option<T>{
    Some(T),
    None
}


pub interface Foo<T> : Bar::foo, Bar2<T> where T : Asdf {
    pub fn foo(a: foo::bar, foo: int);
    pub fn foo3() -> mut u8;
    mut pub fn foo2(a: u8, b: (u8, u8));
    pub fn bar<T>(t: T);
    pub fn qux<T1, T2>(value: T1) where T1 : SomeInterface<T2>;
    pub fn qux2<T1, T2>(value: T1) -> T2 where T1 : SomeInterface<T2>;

    pub get x() -> u8;
    pub mut get y() -> mut Bar<T>;

    pub set x(a: int);
    pub set xy(y: u8);

    #[foo] set x(value: u8);
}

let bar: T;
mut let foo: u8;
let x: Foo<T>;

pub struct Foo<T>  where T : Foobar {
    foo: int;
    pub mut bar: int;
}

pub struct Foo<T> where T : Foobar {
    pub mut x: T;
    pub y: T;
} destructures into (x, y);

pub struct Foo(x: int, y: int);

struct Bar {} destructures into (x, y);

alias bar<T> = (foo, std::map<asdf, T>) where T : numeric;
