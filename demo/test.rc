use std::foo::;

mod main;

pub enum Option<T>{
    Some(T),
    None
}

pub interface Foo<T> : Bar, Bar2<T> where T : Asdf {
    pub fn foo();
    pub fn foo3() -> mut u8;
    mut pub fn foo2(a: u8, b: (u8, u8));
    pub fn bar<T>(t: T);
    pub fn qux<T1, T2>(value: T1) where T1 : SomeInterface<T2>;
    pub fn qux2<T1, T2>(value: T1) -> T2 where T1 : SomeInterface<T2>;

    pub get x -> u8;
    pub mut get y -> mut Bar<T>;

    set x(value: u8);
}

let bar: T;
mut let foo: u8;
pub let x: Foo<T>;

pub struct Foo<T> {

} where T : Foobar;

pub struct Foo<T> where T : Foobar {
    pub x: T;
    pub y: T;
} destructures into (x, y);

impl<T> for Foo<T> {
    Foo(x: T, y: T) {
        this.x = x;
        this.y = y;
    }
}

pub struct Foo(x: int, y: int);

fn foo(f: Foo) -> Foo {
    /*
    let g = Foo(1,2);
    return f with {
        x: 12,
    };
    */
}

struct Bar {} foo destructures into (x, y);


fn foo<T>(callback: fn(Foo<T>)){
    123 asdf;
}